---
title: "GodotでのUI構築を理解する"
emoji: "🎉"
type: "tech" # tech: 技術記事 / idea: アイデア
topics: [game,Godot]
published: false
---

これから作成するゲームの仕様を考えつつ、サンプル実装を行いたい。その際にUI部分に対する実装方法と何ができるかを知る必要があったので情報を探した。チュートリアルのManualにUIのセクションに説明があるので、これを読み込んで理解しようと思う。
https://docs.godotengine.org/en/stable/tutorials/ui/index.html#ui-building-blocks

最初に作成するのはカードゲームがよいと考えていて、これにはContainerを利用するのがいいとにらんでいるので、特に理解しておきたいと考えている。

# User interface (UI) 概要
Godotにおける基本的なGUI構築を知る。このマニュアルは3つの章からなる。

## 1.UI building blocks
Godotの基本を踏襲して、ユーザーインターフェースもノードで構築する。この際に利用されるのはコントロールノードと呼ばれるノードだ。コントロールノードには多くの種類があり、GUIの特定のタイプを作成するのに便利だ。理解を補助のために、コンテンツとレイアウトの2つのグループに分けることができます。
#### コンテンツ
以下が代表例
- Buttons（チュートリアルの中でも登場している）
- Labels
- LineEdits and TextEdits

#### レイアウト
以下が代表例
- BoxContainers
- MarginContainers（こいつを理解したい）
- ScrollContainers
- TabContainers
- Popups

以下のページで個々のコントロールを学習することができる。(URL後で張る)
- Size and anchors
- Using Containers
- Custom GUI controls
- Keyboard/Controller Navigation and Focus
- Control node gallery

（私は基礎を固めるために上からやっていく。）

## 2.GUI skinning and themes
Godot には、コントロールノードのための詳細なスキニング/テーマ設定システムがある（スキニングってなんだ？）。このセクションのページでは、このシステムの利点とプロジェクトでの設定方法について説明する。

- Introduction to GUI skinning
- Using the theme editor
- Theme type variations
- Using Fonts

## 3.Control node tutorials
以下の記事で、特定のコントロールノードを使用する際の具体的な詳細を説明する。

- BBCode in RichTextLabel

## Size and anchors
ゲームが常に同じデバイスで、同じ解像度で実行されるのであれば、コントロール（領域のようなもの？）の位置決めは、それぞれの位置とサイズを設定するだけの簡単な問題だ。残念ながら、そのような状況はめったにない。

標準的な解像度とアスペクト比を持っているのは、現在ではテレビだけだ。パソコンのモニターからタブレット、携帯ゲーム機、携帯電話に至るまで、それ以外のものはすべて解像度とアスペクト比が異なる。

これを処理する方法はいくつかあるが、とりあえず画面の解像度が変わり、コントロールの位置を変更する必要があると想像してみよう。あるものは画面の下部に、あるものは画面の上部に、あるいは左右の余白に沿わせる必要があるだろう。

これに対しては、コントロールのマージン・プロパティを編集することで調整する。各コントロールには、左、右、下、上の4つのマージンがあり、コントロールのそれぞれのエッジに対応している。デフォルトでは、すべてのマージンは、親コントロールの左上隅または（親コントロールがない場合）ビューポートからの相対的な距離をピクセルで表します。

コントロールの幅を広くするには、右マージンを大きくするか、左マージンを小さくすればよい。これにより、コントロールの正確な配置と形状を設定することができます。

アンカー・プロパティは、マージンの距離を相対的に調整します。各マージンには個別のアンカーがあり、親の始点から終点まで調整できます。つまり、垂直方向（上端、下端）のアンカーは、0.5を中心として0（親の上端）から1.0（親の下端）まで調整され、コントロールのマージンはその点を基準として配置される。水平方向（左、右）のアンカーも同様に、親の左から右へ調整します。

コントロールの端をアンカーポイントより上または左にしたい場合は、マージン値を負に変更する必要がある。

例：水平アンカーを1に変更すると、マージン値は親コントロールまたはビューポートの右上隅からの相対値になります。

### Centering a control

コントロールを親の中央に配置するには、アンカーを0.5に設定し、各マージンを関連する寸法の半分に設定します。たとえば、以下のコードは、TextureRectを親の中央に配置する方法を示しています：

```
var rect = TextureRect.new()
rect.texture = load("res://icon.png")
rect.anchor_left = 0.5
rect.anchor_right = 0.5
rect.anchor_top = 0.5
rect.anchor_bottom = 0.5
var texture_size = rect.texture.get_size()
rect.offset_left = -texture_size.x / 2
rect.offset_right = texture_size.x / 2
rect.offset_top = -texture_size.y / 2
rect.offset_bottom = texture_size.y / 2
add_child(rect)
```

### Layout Presets

マージンやアンカーの値を手動で調整する代わりに、ビューポートの上にあるツールバーのレイアウトメニューを使うことができます。センタリング以外にも、コントロールノードの位置合わせやサイズ変更のための多くのオプションが用意されています。

## Using Containers

アンカーは、GUIにおける基本的な複数解像度処理のために、異なるアスペクト比を扱う効率的な方法である、

より複雑なユーザーインターフェースの場合、アンカーは使いづらくなります。

これは、RPG、オンラインチャット、タイクーン、シミュレーションなどのゲームの場合によく見られます。また、より高度なレイアウト機能が必要になるケースとして、ゲーム内ツール（または単にツール）があります。

これらの状況ではすべて、高度なレイアウトや書式設定を備えた、より高機能なOSライクなユーザーインターフェイスが必要になります。そのためには、コンテナーがより便利です。

### Container layout
コンテナは膨大なレイアウトパワーを提供する（一例として、Godotエディタのユーザーインターフェースはすべてコンテナを使っている）

Container由来のノードが使用されると、すべての子Controlノードは自身の位置決め能力を放棄します。つまり、Containerがそれらのノードの位置を制御し、これらのノードを手動で変更しようとすると、無視されるか、次に親のサイズが変更されたときに無効になります。

同様に、Container 派生ノードがサイズ変更されると、使用されているコンテナのタイプに基づいた動作で、すべての子ノードがそれに従って再配置されます

コンテナの本当の強みは、（ノードとして）入れ子にできることで、非常に複雑なレイアウトを簡単にリサイズしながら作成できる。

### Sizing option
ノードをコンテナに追加するとき、コンテナが各子ノードをどのように扱うかは、主にコンテナのサイズ設定オプションに依存します。これらのオプションは、コンテナの子であるコントロールのレイアウトを検査することで見つけることができます。

サイジングオプションは縦方向と横方向で独立しており、すべてのコンテナで利用できるわけではない（ほとんどのコンテナで利用できる）


- Fill: コントロールがコンテナ内の指定された領域を満たすようにする。コントロールが拡張されるかどうかに関係なく（下記参照）、これがオンにトグルされているときのみ（デフォルトでそうなっている）、指定された領域を満たします。

- Expand: 親コンテナ内の（各軸の）スペースをできるだけ広く使おうとする。拡張しないコントロールは、拡張するコントロールによって押しのけられます。拡張するコントロールの間で、互いから取るスペースの量は、Stretch Ratio（下記参照）によって決定されます。このオプションは、親コンテナが適切なタイプである場合にのみ利用可能です。たとえば、HBoxContainerには、水平方向のサイズ調整用にこのオプションがあります。

- Shrink Begin: 拡大するときは、拡大された領域の左側か上側にとどまるようにする。

- Shrink Center: 拡大するときは、拡大したエリアの中心にとどまるようにする。

- Shrink: 拡大するときは、拡大された領域の右か下にとどまるようにする。

- Stretch Ratio: 拡張されたコントロールが互いに関連して利用可能なスペースを占める割合。2 "のコントロールは "1 "のコントロールの2倍のスペースを占有する。

これらのフラッグがどのように機能するかをよりよく把握するために、これらのフラッグと異なるコンテナを使って実験することをお勧めする。

### Container types
Godotは、異なる目的を果たすために、いくつかのコンテナタイプを提供する。
- Box Container
HBoxContainer と VBoxContainer を介して子コントロールを垂直または水平に配置します。指定された方向と逆の場合（水平コンテナに対して垂直のように）、子コントロールを展開します。
これらのコンテナは、Expandフラグが設定された子供用のRatioプロパティを使用します。
- Grid Container
グリッドレイアウトに子コントロールを配置します（GridContainerを介して、列の数を指定する必要があります）。垂直方向と水平方向の両方の拡張フラグを使用します。
- Margin Container
子コントロールは、MarginContainerを介して、このコントロールの境界に向かって拡張されます。パディングは、テーマの設定に応じてマージンに追加されます。
繰り返しますが、マージンはThemeの値なので、各コントロールの定数オーバーライドセクションから編集する必要があることに注意してください：
- Tab Container
TabContainerを介して複数の子コントロールを重ね合わせ、現在のコントロールだけを表示できるようにします。使い勝手がよさそうだ。
タブのタイトルはデフォルトでノード名から生成されます（ただし、TabContainer APIでオーバーライドできます）。
タブの配置やStyleBoxなどの設定は、TabContainerテーマのオーバーライドで変更できます。

- Split Container
タイトルはデフォルトでノード名から生成されます（ただし、TabContainer APIでオーバーライドできます）。
タブの配置やStyleBoxなどの設定は、TabContainerテーマのオーバーライドで変更できます。
敷居をドラッグすることで、両子間のサイズ関係を変更することができる

- Panel Container
StyleBox を描画し、子要素を展開してその領域全体をカバーするコンテナです (PanelContainer を介して、StyleBox のマージンを尊重します)。これは、水平方向と垂直方向の両方のサイズ設定オプションを尊重します。

- Scroll Container
単一の子ノードを受け入れます（Ex.VBoxContainerなど）。このノードがコンテナより大きい場合、（ScrollContainerを介して）ノードをパン（平行移動）できるようにスクロールバーが追加されます。垂直方向と水平方向の両方のサイズオプションが尊重され、プロパティで軸ごとに動作をオンまたはオフにできます。
子コントロールを移動させるには、マウスホイールやタッチドラッグ（タッチ操作が可能な場合）も有効です。

- SubViewport Container
これは特別なコントロールで、1つのViewportノードだけを子として受け入れ、それを（SubViewportContainerを介して）画像であるかのように表示します。

### Creating custom Containers
スクリプトを使用してカスタムコンテナを作成することも可能です。以下は、矩形サイズに子ノードを収めるコンテナの例である：

```
extends Container

func _notification(what):
	if what == NOTIFICATION_SORT_CHILDREN:
		# Must re-sort the children
		for c in get_children():
			# Fit to own size
			fit_child_in_rect(c, Rect2(Vector2(), rect_size))

func set_some_setting():
	# Some setting changed, ask for children re-sort.
	queue_sort()
```

## Custom GUI controls
割愛

## Keyboard/Controller Navigation and Focus
ナビゲーションとインタラクションのために、キーボードとコントローラーをフルサポートすることは、ユーザーインターフェースの一般的な要件です。アクセシビリティの向上（すべての人がマウスやタッチ操作でインタラクションを行えるわけではありません）と、コンソールゲーム機（あるいはPCでコントローラーを使ってゲームをすることを好む人たち）に対応するためです。

キーボードやコントローラーを使ってUI要素間を移動するには、アクティブに選択されているノードを変更します。これはUIフォーカスの変更とも呼ばれます。Godotのすべてのコントロールノードは、フォーカスを持つことができます。デフォルトでは、いくつかのコントロールノードは ui_up、ui_down、ui_focus_next などの組み込み UI アクションに反応して自動的にフォーカスを取得する機能を持っています。これらのアクションは入力マップのプロジェクト設定で見ることができ、変更することもできます。
(これらのアクションはフォーカスのために使用されるため、ゲームプレイのコードに使用してはならない)

Neighborオプションは、矢印キーやコントローラーのDパッドを使うような4方向ナビゲーションのノードを定義するために使われます。例えば、下矢印で下に移動するときやDパッドを押し下げるときは一番下のネイバーが使われます。Next "と "Previous "オプションは、デスクトップOSのTabのようなフォーカスシフトボタンで使用されます。
(ノードは非表示になるとフォーカスを失うことがある。)

モード設定はノードのフォーカス方法を定義します。Allは、マウスでクリックするか、キーボードやコントローラで選択することによって、そのノードに焦点を合わせることができることを意味します。Clickは、クリックすることによってのみフォーカスできることを意味します。最後に None は、まったくフォーカスできないことを意味します。例えば、ラベルノードはデフォルトで "None "に設定され、ボタンは "All "に設定されます。

フォーカスとナビゲーションのためにシーンを適切に設定してください。ノードにフォーカスネイバーが設定されていない場合、エンジンは自動的に次のコントロールを推測しようとします。これは、特に垂直方向や水平方向のナビゲーション フローが明確に定義されていない複雑なユーザー インターフェイスでは、意図しない動作になる可能性があります。

### Necessary code
キーボードとコントローラのナビゲーションを正しく動作させるには、シーンの開始時に、どのノードもコードを使ってフォーカスされている必要があります。これをしないと、ボタンやキーを押しても何もできません。以下は、コードで初期フォーカスを設定する基本的な例です：
```
func _ready():
	$StartButton.grab_focus()
```
これで、シーンが始まると、"Start Button "ノードがフォーカスされ、キーボードやコントローラーを使って、そのノードと他のUIエレメントの間をナビゲートできるようになります。


## Control node gallery
コントロールのサンプル実装が存在する。ただしVer3系のエンジン向けなので、オープンする際にConvertする必要がある。
https://godotengine.org/asset-library/asset/890