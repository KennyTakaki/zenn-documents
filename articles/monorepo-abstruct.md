---
title: "はじめてのモノレポ構築記録 – pnpm × Turborepo × AWS で少しずつ整えてみた"
emoji: "💨"
type: "tech" # tech: 技術記事 / idea: アイデア
topics: ["AWS","モノレポ"]
published: false
---

# モノレポ仕様と設計ドキュメント（概要）

# **はじめに**
## 本記事の目的
本記事では、私がこれまでに構築してきたモノレポ環境の仕様と設計について整理し、技術的な背景や採用したツール群を体系的にまとめます。  
この環境は、複数のアプリケーションと共通パッケージを効率的に管理することを目的としており、CI/CD・インフラ・コード品質・開発体験（DX）までを含めた統合的な開発基盤を目指しています。  

単なる備忘録に留めず、同じようにモノレポを導入しようとしているエンジニアやチームにとって、参考になる実践的な知見を共有することを狙いとしています。

## 対象読者
- モノレポ環境の導入を検討している個人開発者や小規模チーム  
- AWS・GitHub Actions・pnpm・Turborepo といったモダンな開発スタックに関心のあるエンジニア  
- セキュリティチェックや CI/CD を組み込んだ統合的な開発基盤を設計したい人  
- DevContainer や VS Code を活用して、ローカル開発と CI 環境を統一したい人  

## モノレポを採用した背景
従来の複数リポジトリ管理では以下の課題がありました。  

- 各アプリケーション／ライブラリごとに依存関係やビルド環境を個別管理する必要がある  
- 共通コードやユーティリティの再利用が煩雑になり、更新やバージョン管理が分散してしまう  
- CI/CD の設定がリポジトリごとに分散し、運用コストが高くなる  

これらを解決するためにモノレポを採用しました。  
モノレポ化することで以下の利点を得ています。  

- **依存関係の一元管理**：pnpm workspace によってライブラリやアプリ間の依存を効率的に解決  
- **ビルド・タスクの高速化**：Turborepo によるキャッシュと並列実行で開発効率を向上  
- **統合的なCI/CD**：GitHub Actions を中心に、dev / prod 環境に応じたデプロイを自動化  
- **コード品質とセキュリティ担保**：ESLint, Prettier, Husky, Gitleaks などによる開発段階での品質チェック  
- **統一された開発体験**：DevContainer と VS Code により、ローカルとCI環境を一致させ再現性を確保  

これらの背景を踏まえ、本記事では「仕様」と「設計」という2つの観点からモノレポ環境を整理していきます。

# **モノレポの全体仕様**
## 管理するアプリケーションとパッケージの構成
最初は「アプリケーションと共通ライブラリを一緒に管理したい」というシンプルな動機からスタートしました。  
個別リポジトリで管理していたときは、ちょっとした変更でも複数のリポジトリを行き来する必要があり、効率が悪いと感じていました。  

そこで、モノレポでは以下のような構成を採用しました。  

- `apps/` : 実際に動作するアプリケーションを配置  
  - 例: Web フロントエンド, API サーバー  
- `packages/` : 複数のアプリケーションから利用する共通パッケージやライブラリを配置  
  - 例: infra（インフラ定義）, ui（共通UIコンポーネント）, utils（共通ユーティリティ関数）  

この「apps」と「packages」の2階層で整理することで、最初から過度に複雑にせず、必要に応じて拡張していけるようにしました。

---

## ワークスペースの基本方針
ワークスペース管理には **pnpm workspace** を採用しました。  

理由は次の通りです。  
- node_modules を賢く共有してくれるため、ディスク容量とインストール時間を節約できる  
- アプリとライブラリ間の依存関係を `pnpm-workspace.yaml` でシンプルに定義できる  
- 最初の小さな構成から大規模な拡張まで対応できる柔軟性がある  

「まずは動くものを作りたい」という気持ちで選びましたが、結果的に後から追加するライブラリやアプリもスムーズに統合できています。

---

## 開発環境の前提条件
開発環境を揃えるのは、重要なポイントでした。  

- **エディタ**は VS Code を採用し、全員が同じ開発体験を得られるようにしました  
- **DevContainer** を用意して、ローカル環境がどこでも再現できるようにしました  
- Node.js のバージョンや AWS CLI などのツール群もコンテナで統一し、環境依存のトラブルを減らしました  

このおかげで「環境構築でつまずく」ことがほぼなくなり、開発に入れるようになっています。  

---

## 振り返り
こうして全体仕様を整理すると、当初は「とにかく一つのリポジトリにまとめる」ことから始めたのですが、結果的に  
- **apps と packages の役割分担**  
- **pnpm workspace による依存関係管理**  
- **DevContainer による再現性の高い開発環境**  

といった要素が自然と揃っていきました。  

大きな設計をいきなり目指すよりも、**「小さく始めて後から拡張する」** という流れが自分には合っていたと感じています。

# 使用しているツール群の一覧

モノレポを構築するにあたり、さまざまなツールを試しました。  
最初からすべてを揃えていたわけではなく、「これが必要かも」と思ったタイミングで追加していきました。  
ここでは現在利用しているツール群と、それぞれを導入した理由・役割をまとめます。

---

## 開発環境
- **VS Code**  
  エディタは VS Code を標準としました。拡張機能が豊富で、TypeScript や AWS 開発との相性も良いためです。  
- **DevContainer**  
  開発環境をチームや CI と揃えるために導入しました。Node.js や AWS CLI などのツールをコンテナにまとめ、環境差異によるトラブルを避けています。  

---

## 生成AI
- **Amazon Q Developer CLI**  
  開発中の試行錯誤を補助するために活用しています。タスクやコード生成のサポートを受けながら、モノレポの整備を進めやすくしています。  

- **Chat GPT Plus**
  セカンドオピニオン的に利用しています。こちらはローカルのエージェントとして利用しているのでなく、方針などを壁打ちするために利用しました。スマホアプリで移動中などに頭の整理をできるのが最大の利点だと感じています。

---

## パッケージ管理
- **pnpm**  
  workspace 機能が強力で、モノレポとの相性が非常に良いです。  
  npm や yarn よりインストール速度が速く、ディスク容量も節約できます。  

---

## タスクランナー
- **Turborepo**  
  モノレポ内のタスクを効率的に管理するために導入しました。  
  キャッシュ機能のおかげで、変更がない部分のビルドをスキップでき、開発効率が大幅に改善しました。  

---

## インフラ管理
- **AWS CDK**  
  現状はまだ S3 バケットの構築にとどまっていますが、将来的に IaC (Infrastructure as Code) を本格導入するために選択しました。  
  TypeScript で書けるため、フロントや API と同じ言語で統一できる点も魅力です。  

---

## CI/CD
- **GitHub Actions**  
  プルリクエストやブランチへの push をトリガーに、Lint やテスト、デプロイを自動化しています。  
  OIDC を使った AWS 認証を組み込み、シークレット管理をシンプルにしました。  

---

## コード品質
- **ESLint**  
  TypeScript/JavaScript の静的解析を行い、バグを防ぎます。  
- **Prettier**  
  コードフォーマットを統一し、レビュー時の無駄な差分を減らしました。  
- **Markdownlint**  
  ドキュメント（README やブログ記事）の整形ルールを統一するために利用しています。  

---

## セキュリティ
- **Gitleaks**  
  誤って API Key やパスワードをコミットしないよう、シークレットスキャンを行います。  
  Husky の pre-commit フックと連携して、自動的にチェックされるようにしました。  

---

## テスト
- **Jest**  
  基本的なユニットテストのフレームワークとして採用しました。  
- **Vitest**  
  フロントエンド側のテストでは Jest より軽量な Vitest も試しています。  
- **React Testing Library**  
  React コンポーネントの挙動をユーザー目線で検証するために導入しました。  

---

## Git Hooks
- **Husky**  
  Git フックを簡単に設定できるツールです。  
  `pre-commit` で Lint や Gitleaks を実行し、問題があればコミットできないようにしています。  

---

## 振り返り
こうして見ると、モノレポの仕様を支えているのは「一度に導入したツール」ではなく、必要に応じて少しずつ追加してきたものばかりです。  
最初は **pnpm + Turborepo** の最低限のセットから始め、後から **ESLint, Prettier, Husky, Gitleaks** を足していきました。  

初心者としては「いきなり完璧なスタックを組む」のは難しいですが、段階的に導入していくことで結果的に今のような構成に育ちました。

# ディレクトリ構成とワークスペース設計

## apps/ と packages/ の役割
モノレポを始めたときに一番迷ったのが「どのようにディレクトリを分けるか」でした。  
最初は全部を一つのフォルダに入れていましたが、だんだん管理が大変になってきたので、以下のような構成に落ち着きました。

- **apps/**  
  実際に動くアプリケーションを置く場所です。  
  例:  
  - `web/` (フロントエンドSPA)  
  - `api/` (APIサーバー)  

- **packages/**  
  複数のアプリで使う共通モジュールやライブラリを置く場所です。  
  例:  
  - `infra/` (CDKによるインフラ定義)  
  - `ui/` (共通Reactコンポーネント)  
  - `utils/` (共通ユーティリティ関数)  

この分け方はシンプルですが、**「アプリ」と「ライブラリ」を物理的に分ける」**ことで頭の整理がつきやすくなりました。  

---

## pnpm-workspace.yaml の定義
pnpm では `pnpm-workspace.yaml` を使って、どのフォルダをワークスペースに含めるかを指定します。  
私の設定はシンプルに以下のようになっています。

```yaml
packages:
  - "apps/*"
  - "packages/*"
```

こうすることで、apps/ と packages/ 配下のプロジェクトが自動的にワークスペースとして認識されます。
これによって、例えば apps/web が packages/ui に依存する場合でも、ローカル開発時には直接リンクされるので、変更がすぐ反映されるのが便利です。


## モジュール間依存関係の方針

初心者のうちは「依存関係がぐちゃぐちゃになるのでは？」という不安がありました。
そこで、自分なりに以下のルールを置きました。
apps → packages への依存はOK
アプリはライブラリを使う想定なので依存してよい
packages → apps への依存はNG

共通ライブラリがアプリに依存すると循環参照になりやすいため禁止
packages 同士の依存は最小限に
どうしても必要な場合だけ依存する（utils など汎用ライブラリは例外）
こうしたルールを決めたことで、依存関係が複雑になりすぎず、管理がしやすくなりました。


## 振り返り

最初は「モノレポって難しそう」と思っていましたが、実際にやってみるとapps と packages を分けるだけでも頭が整理できる、pnpm-workspace.yaml を書くだけで依存管理が楽になる、と、意外とシンプルに始められることがわかりました。
このあたりから「モノレポって実は初心者にも優しいのでは？」と感じ始めました。



# タスク実行とキャッシュ設計

モノレポを導入したときに次に悩んだのが、**「複数パッケージのビルドやテストをどう効率よく回すか」**でした。  
単純に `pnpm -r build` のように全パッケージを毎回実行すると、変更がないパッケージもビルドされてしまい、時間が無駄になります。  

そこで導入したのが **Turborepo** です。  
キャッシュや依存解決の仕組みを活用することで、実際の開発効率が大きく変わりました。

---

## Turborepo によるタスク定義

Turborepo では、ルートに `turbo.json` を配置してタスクを定義します。  
私の最初の設定はシンプルに以下のようなものでした。

```json
{
  "$schema": "https://turbo.build/schema.json",
  "pipeline": {
    "build": {
      "dependsOn": ["^build"],
      "outputs": ["dist/**", "build/**"]
    },
    "lint": {
      "outputs": []
    },
    "test": {
      "dependsOn": ["^build"],
      "outputs": []
    },
    "dev": {
      "cache": false
    }
  }
}
```
ここでのポイントは以下です。

- build タスク
自分自身のビルドだけでなく、依存しているパッケージのビルドも実行される

- lint / test
キャッシュ可能だが成果物を残さないので outputs は空

- dev
ローカル開発用なのでキャッシュを無効化

この最小構成だけでも「どのタスクがどのパッケージに依存しているか」を明示でき、全体を見渡しやすくなりました。

## 並列実行と依存解決

Turborepo はタスクを並列で実行してくれます。
例えば turbo run build を実行すると、依存関係を解決した上で、独立しているパッケージのビルドは同時に走ります。

これによって「待ち時間が長いビルド」も並列化され、従来の直列実行よりかなり早くなりました。
小さな改善に見えて、日々の開発体験に大きく効いてきます。

## キャッシュ戦略（ローカル・リモート）

Turborepo の最大の魅力は キャッシュ機能 です。

### ローカルキャッシュ
直前に実行したタスクの結果を保存し、同じ入力なら再実行をスキップします。
例: 前回ビルドからコードが変わっていなければ、次回は「キャッシュヒット」で瞬時に完了します。

### リモートキャッシュ
（未導入ですが）将来的には CI との連携で活用予定です。開発者のローカルと CI でキャッシュを共有できるようになれば、CI のビルド時間が劇的に短縮されるはずです。

キャッシュ戦略を導入しただけで、特にビルドの繰り返しにかかる時間が大幅に短縮されました。


## 実際のコマンド例
-すべてのパッケージでビルド

```
pnpm run build:all
```
→ turbo.json の設定に従って、依存解決＋並列実行が走ります。

- 特定のパッケージだけ実行

```
pnpm --filter @frommiddle/web build
```

## 振り返り
最初は「タスクランナーってなくてもいいのでは？」と思っていました。
しかし、モノレポのように複数アプリ・複数パッケージを管理すると、**「どのタスクをいつ実行すべきか」**を明確に定義しないとすぐに破綻します。

Turborepo を入れてみた結果、依存関係を意識せずタスクを実行できる安心感

キャッシュによる大幅な時間短縮ローカルと CI/CD の一貫性といったメリットを体感できました。

「まずは build と lint と test を定義する」程度でも十分に効果があるので、初心者が最初導入するツールとしてもおすすめできます。





# **インフラ設計（現状）**
   - 環境ごとの S3 バケット作成
   - 簡易的なステージ分離（dev / prod）
   - 今後の拡張余地（CDK による IaC, Route 53, API Gateway など）

# **CI/CD パイプライン**
   - GitHub Actions のワークフロー
   - OIDC による AWS 認証
   - dev / prod 環境ごとのデプロイ戦略
   - キャッシュとビルド成果物の取り扱い

# **コード品質とセキュリティ設計**
   - ESLint / Prettier / Markdownlint の適用範囲
   - Husky フックでの自動チェック
   - Gitleaks によるシークレットスキャン
   - セキュリティ強化のベストプラクティス

# **開発体験（DX）設計**
   - DevContainer の構成
   - ローカル開発と CI 環境の統一
   - テスト戦略（Jest, React Testing Library）
   - デバッグ・監視の仕組み

# **まとめと今後の展望**
    - 現状の仕様の到達点
    - 今後追加を検討している機能
    - 改善サイクルの回し方
