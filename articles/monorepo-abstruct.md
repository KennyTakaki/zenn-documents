---
title: "monorepo-abstruct"
emoji: "💨"
type: "tech" # tech: 技術記事 / idea: アイデア
topics: ["AWS","モノレポ"]
published: false
---

# モノレポ仕様と設計ドキュメント（概要）

# **はじめに**
## 本記事の目的
本記事では、私がこれまでに構築してきたモノレポ環境の仕様と設計について整理し、技術的な背景や採用したツール群を体系的にまとめます。  
この環境は、複数のアプリケーションと共通パッケージを効率的に管理することを目的としており、CI/CD・インフラ・コード品質・開発体験（DX）までを含めた統合的な開発基盤を目指しています。  

単なる備忘録に留めず、同じようにモノレポを導入しようとしているエンジニアやチームにとって、参考になる実践的な知見を共有することを狙いとしています。

## 対象読者
- モノレポ環境の導入を検討している個人開発者や小規模チーム  
- AWS・GitHub Actions・pnpm・Turborepo といったモダンな開発スタックに関心のあるエンジニア  
- セキュリティチェックや CI/CD を組み込んだ統合的な開発基盤を設計したい人  
- DevContainer や VS Code を活用して、ローカル開発と CI 環境を統一したい人  

## モノレポを採用した背景
従来の複数リポジトリ管理では以下の課題がありました。  

- 各アプリケーション／ライブラリごとに依存関係やビルド環境を個別管理する必要がある  
- 共通コードやユーティリティの再利用が煩雑になり、更新やバージョン管理が分散してしまう  
- CI/CD の設定がリポジトリごとに分散し、運用コストが高くなる  

これらを解決するためにモノレポを採用しました。  
モノレポ化することで以下の利点を得ています。  

- **依存関係の一元管理**：pnpm workspace によってライブラリやアプリ間の依存を効率的に解決  
- **ビルド・タスクの高速化**：Turborepo によるキャッシュと並列実行で開発効率を向上  
- **統合的なCI/CD**：GitHub Actions を中心に、dev / prod 環境に応じたデプロイを自動化  
- **コード品質とセキュリティ担保**：ESLint, Prettier, Husky, Gitleaks などによる開発段階での品質チェック  
- **統一された開発体験**：DevContainer と VS Code により、ローカルとCI環境を一致させ再現性を確保  

これらの背景を踏まえ、本記事では「仕様」と「設計」という2つの観点からモノレポ環境を整理していきます。

# **モノレポの全体仕様**
## 管理するアプリケーションとパッケージの構成
最初は「アプリケーションと共通ライブラリを一緒に管理したい」というシンプルな動機からスタートしました。  
個別リポジトリで管理していたときは、ちょっとした変更でも複数のリポジトリを行き来する必要があり、効率が悪いと感じていました。  

そこで、モノレポでは以下のような構成を採用しました。  

- `apps/` : 実際に動作するアプリケーションを配置  
  - 例: Web フロントエンド, API サーバー  
- `packages/` : 複数のアプリケーションから利用する共通パッケージやライブラリを配置  
  - 例: infra（インフラ定義）, ui（共通UIコンポーネント）, utils（共通ユーティリティ関数）  

この「apps」と「packages」の2階層で整理することで、最初から過度に複雑にせず、必要に応じて拡張していけるようにしました。

---

## ワークスペースの基本方針
ワークスペース管理には **pnpm workspace** を採用しました。  

理由は次の通りです。  
- node_modules を賢く共有してくれるため、ディスク容量とインストール時間を節約できる  
- アプリとライブラリ間の依存関係を `pnpm-workspace.yaml` でシンプルに定義できる  
- 最初の小さな構成から大規模な拡張まで対応できる柔軟性がある  

「まずは動くものを作りたい」という気持ちで選びましたが、結果的に後から追加するライブラリやアプリもスムーズに統合できています。

---

## 開発環境の前提条件
開発環境を揃えるのは、重要なポイントでした。  

- **エディタ**は VS Code を採用し、全員が同じ開発体験を得られるようにしました  
- **DevContainer** を用意して、ローカル環境がどこでも再現できるようにしました  
- Node.js のバージョンや AWS CLI などのツール群もコンテナで統一し、環境依存のトラブルを減らしました  

このおかげで「環境構築でつまずく」ことがほぼなくなり、開発に入れるようになっています。  

---

## 振り返り
こうして全体仕様を整理すると、当初は「とにかく一つのリポジトリにまとめる」ことから始めたのですが、結果的に  
- **apps と packages の役割分担**  
- **pnpm workspace による依存関係管理**  
- **DevContainer による再現性の高い開発環境**  

といった要素が自然と揃っていきました。  

大きな設計をいきなり目指すよりも、**「小さく始めて後から拡張する」** という流れが自分には合っていたと感じています。

# **使用しているツール群の一覧**
   - **開発環境**
     - VS Code
     - DevContainer
   - **生成AI**
     - Amazon Q Developer CLI
   - **パッケージ管理**
     - pnpm
   - **タスクランナー**
     - Turborepo
   - **インフラ管理**
     - AWS CDK
   - **CI/CD**
     - GitHub Actions
   - **コード品質**
     - ESLint
     - Prettier
     - Markdownlint
   - **セキュリティ**
     - Gitleaks
   - **テスト**
     - Jest
     - Vitest
     - React Testing Library
   - **Git Hooks**
     - Husky

# **ディレクトリ構成とワークスペース設計**
   - `apps/` と `packages/` の役割
   - `pnpm-workspace.yaml` の定義
   - モジュール間依存関係の方針

# **タスク実行とキャッシュ設計**
   - Turborepo によるタスク定義
   - 並列実行と依存解決
   - キャッシュ戦略（ローカル・リモート）

# **インフラ設計（現状）**
   - 環境ごとの S3 バケット作成
   - 簡易的なステージ分離（dev / prod）
   - 今後の拡張余地（CDK による IaC, Route 53, API Gateway など）

# **CI/CD パイプライン**
   - GitHub Actions のワークフロー
   - OIDC による AWS 認証
   - dev / prod 環境ごとのデプロイ戦略
   - キャッシュとビルド成果物の取り扱い

# **コード品質とセキュリティ設計**
   - ESLint / Prettier / Markdownlint の適用範囲
   - Husky フックでの自動チェック
   - Gitleaks によるシークレットスキャン
   - セキュリティ強化のベストプラクティス

# **開発体験（DX）設計**
   - DevContainer の構成
   - ローカル開発と CI 環境の統一
   - テスト戦略（Jest, React Testing Library）
   - デバッグ・監視の仕組み

# **まとめと今後の展望**
    - 現状の仕様の到達点
    - 今後追加を検討している機能
    - 改善サイクルの回し方
